# Code Generated by Sidekick is for learning and experimentation purposes only.
import os
import subprocess
import time
import json
from langchain_groq import ChatGroq
from dotenv import load_dotenv

load_dotenv()
GROQ_API_KEY = os.getenv("GROQ_API_KEY")

class DebugAndServeNode:
    """
    After code generation, this node:
      1. Runs "npm install" in the Angular project directory.
      2. Runs "ng serve" with a short timeout (15 sec) to capture error logs.
      3. If errors are detected, sends the error log to the LLM to get a JSON patch (mapping file paths to corrected code).
         The LLM is strictly instructed to output only valid JSON (no markdown formatting or extra text).
      4. Applies the patch to update the project files.
      5. Repeats until no errors remain or a maximum number of iterations is reached.
      6. Finally, launches "ng serve" interactively.
    """

    def __init__(self):
        self.base_path = os.getcwd()
        # Assume the project root is "angularapp" (adjust if needed)
        self.project_root = "angularapp"
        self.angular_project_path = os.path.join(self.base_path, self.project_root)
        if not os.path.isdir(self.angular_project_path):
            raise FileNotFoundError(f"Project directory not found: {self.angular_project_path}")
        self.llm = ChatGroq(model_name="llama3-8b-8192", api_key=GROQ_API_KEY)

    def run_npm_install(self):
        cmd = "npm install"
        print(f"Running: {cmd} in {self.angular_project_path}")
        result = subprocess.run(cmd, shell=True, cwd=self.angular_project_path, text=True, capture_output=True)
        if result.returncode != 0:
            print("npm install error:", result.stderr)
        else:
            print(result.stdout)

    def run_ng_serve(self, timeout=15):
        """
        Runs "ng serve" with a timeout (in seconds) and returns the error output (stderr).
        If the process times out, it is killed and any error output is returned.
        """
        cmd = "ng serve"
        print(f"Running: {cmd} in {self.angular_project_path} (timeout: {timeout} sec)")
        proc = subprocess.Popen(cmd, shell=True, cwd=self.angular_project_path,
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        try:
            stdout, stderr = proc.communicate(timeout=timeout)
        except subprocess.TimeoutExpired:
            proc.kill()
            stdout, stderr = proc.communicate()
        return stderr

    def debug_errors(self, error_log):
        """
        Sends the error log to the LLM with a prompt that instructs it to generate a JSON patch.
        The JSON patch should be an object mapping relative file paths (from the project root)
        to the complete, corrected code for that file.
        The prompt strictly instructs the LLM to output only raw JSON (no markdown formatting, triple backticks, or extra text).
        """
        prompt = f"""You are an expert Angular developer and debugging specialist.
Analyze the following Angular error log and generate a JSON patch.
The JSON patch should be an object where each key is a relative file path (from the project root) that needs to be modified,
and its value is the complete corrected code for that file.
Do not include any markdown formatting, triple backticks, or extra text. Return only valid JSON.
Error Log:{error_log}"""
        response = self.llm.invoke(prompt)
        patch_text = response.content.strip()
        try:
            patch = json.loads(patch_text)
        except Exception as e:
            print("Error parsing patch JSON:", e)
            print("Patch text received:")
            print(patch_text)
            patch = {}
        return patch

    def apply_patch(self, patch):
        """
        Applies the JSON patch by writing the corrected code into the respective files.
        Each key in the patch is a relative file path (e.g., "src/app/components/dashboard/dashboard.component.ts").
        """
        for rel_path, new_code in patch.items():
            target_path = os.path.join(self.angular_project_path, rel_path)
            os.makedirs(os.path.dirname(target_path), exist_ok=True)
            with open(target_path, "w", encoding="utf-8") as f:
                f.write(new_code)
            print(f"Applied patch to {target_path}")

    def run(self):
        # Step 1: Install dependencies
        self.run_npm_install()

        max_iterations = 5
        iteration = 0
        while iteration < max_iterations:
            iteration += 1
            print(f"\nDebug iteration {iteration}: Running ng serve for error checking...")
            error_log = self.run_ng_serve(timeout=15)
            # Check if error_log contains significant errors; adjust the condition as needed.
            if not error_log or "ERROR" not in error_log.upper():
                print("No significant errors detected.")
                break
            print("Errors detected:")
            print(error_log)
            patch = self.debug_errors(error_log)
            if not patch:
                print("No patch generated. Stopping debug iterations.")
                break
            self.apply_patch(patch)
            print("Waiting for patch to take effect...")
            time.sleep(3)

        print("\nStarting Angular application interactively...")
        # Start ng serve interactively without a timeout
        subprocess.run("ng serve", shell=True, cwd=self.angular_project_path)

if __name__ == "__main__":
    node = DebugAndServeNode()
    node.run()
