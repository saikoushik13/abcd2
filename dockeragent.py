# Code Generated by Sidekick is for learning and experimentation purposes only.

import os
import json
import re
from langchain_groq import ChatGroq
from dotenv import load_dotenv

load_dotenv()
GROQ_API_KEY = os.getenv("GROQ_API_KEY")

class DockerfileGenerationNode:
    """
    Generates a Dockerfile for an Angular project using details extracted from the application.
    It reads the project root from folder_structure.txt (the first "DIR:" line) and uses os.getcwd() as the base directory.
    It then creates a dictionary with application details (such as base image, working directory, files to copy, etc.)
    and sends these details to the LLM with a strict prompt. The LLM is instructed to output only the raw Dockerfile code.
    The generated Dockerfile is written to the project root.
    """
    def __init__(self):
        # Use the current working directory as the base directory.
        self.base_path = os.getcwd()
        self.folder_structure_file = os.path.join(self.base_path, "folder_structure.txt")
        self.project_root = self.get_project_root()  # e.g. "dna-ecosystem"
        self.angular_project_path = os.path.join(self.base_path, self.project_root)
        self.llm = ChatGroq(model_name="llama3-8b-8192", api_key=GROQ_API_KEY)

    def get_project_root(self):
        """
        Reads folder_structure.txt and returns the first plain directory name as the project root.
        Assumes the file has a line like "DIR: dna-ecosystem"
        """
        if not os.path.exists(self.folder_structure_file):
            raise FileNotFoundError(f"folder_structure.txt not found in {self.base_path}")
        with open(self.folder_structure_file, "r", encoding="utf-8") as f:
            for line in f:
                stripped = line.strip()
                if stripped.startswith("DIR:"):
                    return stripped[4:].strip()
        raise ValueError("No project root found in folder_structure.txt.")

    def extract_app_details(self):
        """
        Prepares a dictionary with key application details extracted from the project.
        In a real scenario, you might read files (like package.json) or configuration files;
        here we set defaults for an Angular project.
        """
        details = {
            "baseImage": "node:14-alpine",  # Default Node.js LTS image
            "workingDirectory": "/usr/src/app",
            "filesToCopy": ["package.json", "package-lock.json", "src/"],
            "dependenciesCommand": "npm install",
            "buildCommand": "ng build --prod",
            "exposedPorts": [4200],
            "runtimeCommand": "npx http-server dist",  # Alternatively, serve via a static server
            "environmentVariables": {"NODE_ENV": "production"},
            "volumes": [],
            "multiStage": True
        }
        return details

    def build_prompt(self, details):
        """
        Constructs a prompt that passes the application details to the LLM.
        The prompt instructs the LLM to generate a complete Dockerfile using these details.
        It emphasizes:
          - Base Image and Operating System details.
          - Working Directory path.
          - Files and directories to copy.
          - Dependency installation command.
          - Build commands.
          - Exposed ports.
          - Runtime command.
          - Environment variables.
          - Additional configuration (volumes, multi-stage builds).
        The prompt instructs the LLM to return only the raw Dockerfile code, without markdown formatting or extra text.
        """
        prompt = f"""You are an expert in Docker containerization for Angular projects.
Based on the following application details, generate a complete Dockerfile.
1. Base Image:
   - Base Image: {details['baseImage']}
   - (This implies an OS/runtime environment based on the image.)
2. Working Directory:
   - Working Directory: {details['workingDirectory']}
3. Application Files:
   - Files and Directories to Copy: {json.dumps(details['filesToCopy'])}
4. Dependencies:
   - Dependencies Installation Command: {details['dependenciesCommand']}
5. Build Commands:
   - Build Command: {details['buildCommand']}
6. Ports:
   - Exposed Ports: {json.dumps(details['exposedPorts'])}
7. Runtime Command:
   - Runtime Command: {details['runtimeCommand']}
8. Environment Variables:
   - Environment Variables: {json.dumps(details['environmentVariables'])}
9. Additional Configuration:
   - Volumes: {json.dumps(details['volumes'])}
   - Multi-Stage Build: {details['multiStage']}
Do not include any markdown formatting, triple backticks, or extra text.
Return only the raw Dockerfile code."""
        return prompt.strip()

    def clean_generated_code(self, code):
        """
        Removes triple backticks from the beginning and end of the generated code, if present.
        """
        code = code.strip()
        if code.startswith("```") and code.endswith("```"):
            lines = code.splitlines()
            if len(lines) >= 3:
                code = "\n".join(lines[1:-1]).strip()
        return code

    def generate_dockerfile(self):
        """
        Generates the Dockerfile by:
          1. Extracting application details.
          2. Building a prompt with these details.
          3. Invoking the LLM.
          4. Cleaning the generated code.
        """
        details = self.extract_app_details()
        prompt_text = self.build_prompt(details)
        response = self.llm.invoke(prompt_text)
        raw_code = response.content.strip()
        dockerfile_code = self.clean_generated_code(raw_code)
        return dockerfile_code

    def write_dockerfile(self, dockerfile_code):
        """
        Writes the generated Dockerfile code to a file named "Dockerfile" in the project root.
        """
        target_path = os.path.join(self.angular_project_path, "Dockerfile")
        with open(target_path, "w", encoding="utf-8") as f:
            f.write(dockerfile_code)
        print(f" Dockerfile written to: {target_path}")

    def run(self):
        dockerfile_code = self.generate_dockerfile()
        self.write_dockerfile(dockerfile_code)

if __name__ == "__main__":
    node = DockerfileGenerationNode()
    node.run()
